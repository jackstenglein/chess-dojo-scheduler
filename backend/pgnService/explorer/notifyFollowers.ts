import {
    AttributeValue,
    BatchWriteItemCommand,
    DynamoDBClient,
    QueryCommand,
    QueryCommandOutput,
} from '@aws-sdk/client-dynamodb';
import { marshall, unmarshall } from '@aws-sdk/util-dynamodb';
import {
    APIGatewayProxyResultV2,
    DynamoDBRecord,
    DynamoDBStreamHandler,
} from 'aws-lambda';

import { ExplorerGame, ExplorerPositionFollower, PgnHeaders, dojoCohorts } from './types';

/**
 * A notification generated by a new ExplorerGame.
 */
interface ExplorerGameNotification {
    /** The username of the person receiving the notification. */
    username: string;

    /** The id of the notification. */
    id: string;

    /** The type of the notification. */
    type: 'EXPLORER_GAME';

    /** The time the notification was last updated. */
    updatedAt: string;

    /** The number of instances of the notification. */
    count: 1;

    /** Metadata about the ExplorerGame. */
    explorerGameMetadata: {
        /** The normalized FEN of the position. */
        normalizedFen: string;

        /** The cohort the game was in. */
        cohort: string;

        /** The id of the game. */
        id: string;

        /** The result of the ExplorerGame, as related to the position. */
        result: string;

        /** The headers of the game. */
        headers: PgnHeaders;
    };
}

const dynamo = new DynamoDBClient({ region: 'us-east-1' });
const explorerTable = process.env.stage + '-explorer';
const notificationTable = process.env.stage + '-notifications';

/**
 * Extracts the ExplorerGames from a list of inserted Explorer objects and saves notifications for them.
 * @param event The DynamoDB stream event that triggered this Lambda. It contains the Explorer table objects.
 */
export const handler: DynamoDBStreamHandler = async (event) => {
    console.log('Event: %j', event);

    for (const record of event.Records) {
        await processRecord(record);
    }
};

/**
 * Notifies all followers of a position about new games in that position.
 * @param record A single DynamoDB stream record to notify users about.
 */
async function processRecord(record: DynamoDBRecord) {
    if (!record.dynamodb?.NewImage) {
        console.log('Skipping record as it has no NewImage');
        return;
    }

    const game = unmarshall(
        record.dynamodb.NewImage as Record<string, AttributeValue>,
    ) as ExplorerGame;

    if (!game.id || !game.id.startsWith('GAME#')) {
        console.log('Skipping record as its id does not start with GAME#');
        return;
    }

    if (game.cohort === 'masters') {
        console.log('Skipping record since it is a masters game');
        return;
    }

    const normalizedFen = game.normalizedFen;
    if (!normalizedFen) {
        console.log('Skipping record as it has no normalizedFen');
        return;
    }

    try {
        let startKey: Record<string, AttributeValue> | undefined = undefined;

        do {
            console.log('Fetching followers for FEN: ', normalizedFen);

            const queryOutput: QueryCommandOutput = await dynamo.send(
                new QueryCommand({
                    KeyConditionExpression: `#fen = :fen AND begins_with ( #id, :id )`,
                    ExpressionAttributeNames: {
                        '#fen': 'normalizedFen',
                        '#id': 'id',
                    },
                    ExpressionAttributeValues: {
                        ':fen': { S: normalizedFen },
                        ':id': { S: 'FOLLOWER#' },
                    },
                    ExclusiveStartKey: startKey,
                    TableName: explorerTable,
                }),
            );

            const followers: ExplorerPositionFollower[] | undefined =
                queryOutput.Items?.map(
                    (item) => unmarshall(item) as ExplorerPositionFollower,
                );
            console.log('Processing %d followers', followers?.length || 0);

            await processFollowers(game, followers);
            startKey = queryOutput.LastEvaluatedKey;
        } while (startKey);
    } catch (err) {
        return handleError(500, err);
    }
}

/**
 * Creates notifications for the provided ExplorerGame for each of the provided followers
 * as necessary. The follower configuration is respected (IE: minCohort, maxCohort, etc).
 * @param game The ExplorerGame that generated the notifications.
 * @param followers The followers to create notifications for.
 * @returns A void promise.
 */
async function processFollowers(
    game: ExplorerGame,
    followers: ExplorerPositionFollower[] | undefined,
) {
    if (!followers || followers.length === 0) {
        console.log('processFollowers: No followers');
        return;
    }

    let notifications: ExplorerGameNotification[] = [];
    for (const follower of followers) {
        const notification = getNotification(game, follower);
        if (notification) {
            notifications.push(notification);
            if (notifications.length == 25) {
                await writeNotifications(notifications);
                notifications = [];
            }
        }
    }

    await writeNotifications(notifications);
}

/**
 * Returns a notification object for the given game and follower.
 * @param game The ExplorerGame that generated the notification.
 * @param follower The ExplorerPositionFollower receiving the notification.
 * @returns The new notification object or null if the follower should not receive a notification for this game.
 */
function getNotification(
    game: ExplorerGame,
    follower: ExplorerPositionFollower,
): ExplorerGameNotification | null {
    if (follower.disableVariations && game.result === 'analysis') {
        console.log('Skipping follower due to disableVariations');
        return null;
    }
    if (
        follower.minCohort &&
        dojoCohorts.indexOf(follower.minCohort) > dojoCohorts.indexOf(game.cohort)
    ) {
        console.log('Skipping follower due to minCohort');
        return null;
    }
    if (
        follower.maxCohort &&
        dojoCohorts.indexOf(follower.maxCohort) < dojoCohorts.indexOf(game.cohort)
    ) {
        console.log('Skipping follower due to maxCohort');
        return null;
    }

    return {
        username: follower.id.replace('FOLLOWER#', ''),
        id: `EXPLORER_GAME|${game.game.cohort}|${game.game.id}`,
        type: 'EXPLORER_GAME',
        updatedAt: new Date().toISOString(),
        count: 1,
        explorerGameMetadata: {
            normalizedFen: game.normalizedFen,
            cohort: game.cohort,
            id: game.game.id,
            result: game.result,
            headers: {
                ...game.game.headers,
                Date: game.game.date,
            },
        },
    };
}

/**
 * Saves the provided notifications to the database.
 * @param notifications The notifications to write to the database.
 * @returns A void promise.
 */
async function writeNotifications(notifications: ExplorerGameNotification[]) {
    if (notifications.length === 0) {
        console.log('writeNotifications: no notifications to write.');
        return;
    }

    try {
        const input = new BatchWriteItemCommand({
            RequestItems: {
                [notificationTable]: notifications.map((n) => ({
                    PutRequest: {
                        Item: marshall(n),
                    },
                })),
            },
            ReturnConsumedCapacity: 'NONE',
        });

        await dynamo.send(input);
    } catch (err) {
        console.error('Failed to batch write notifications: ', err);
    }
}

function handleError(code: number, err: any): APIGatewayProxyResultV2 {
    console.error(err);

    return {
        statusCode: code,
        isBase64Encoded: false,
        headers: {
            'Content-Type': 'application/json',
            'Access-Control-Allow-Origin': '*',
        },
        body: JSON.stringify(err),
    };
}
